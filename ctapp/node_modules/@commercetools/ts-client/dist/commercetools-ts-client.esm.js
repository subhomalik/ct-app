import fetch$1 from 'node-fetch';
import { v4 } from 'uuid';
import { Buffer } from 'buffer/';
import AbortController from 'abort-controller';

function toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}

function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

const HEADERS_CONTENT_TYPES = ['application/json', 'application/graphql'];
const CONCURRENCT_REQUEST = 20;
const CTP_API_URL = 'https://api.europe-west1.gcp.commercetools.com';
const CTP_AUTH_URL = 'https://auth.europe-west1.gcp.commercetools.com';
const DEFAULT_HEADERS = ['content-type', 'access-control-allow-origin', 'access-control-allow-headers', 'access-control-allow-methods', 'access-control-expose-headers', 'access-control-max-ag', 'x-correlation-id', 'server-timing', 'date', 'server', 'transfer-encoding', 'access-control-max-age', 'content-encoding', 'x-envoy-upstream-service-time', 'via', 'alt-svc', 'connection'];

function DefineError(statusCode, message, meta = {}) {
  // eslint-disable-next-line no-multi-assign
  this.status = this.statusCode = this.code = statusCode;
  this.message = message;
  Object.assign(this, meta);
  this.name = this.constructor.name;
  // eslint-disable-next-line no-proto
  this.constructor.prototype.__proto__ = Error.prototype;
  if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
}
function NetworkError(...args) {
  DefineError.call(this, 0, ...args);
}
function HttpError(...args) {
  DefineError.call(this, ...args);
}
function BadRequest(...args) {
  DefineError.call(this, 400, ...args);
}
function Unauthorized(...args) {
  DefineError.call(this, 401, ...args);
}
function Forbidden(...args) {
  DefineError.call(this, 403, ...args);
}
function NotFound(...args) {
  DefineError.call(this, 404, ...args);
}
function ConcurrentModification(...args) {
  DefineError.call(this, 409, ...args);
}
function InternalServerError(...args) {
  DefineError.call(this, 500, ...args);
}
function ServiceUnavailable(...args) {
  DefineError.call(this, 503, ...args);
}
function getErrorByCode(code) {
  switch (code) {
    case 0:
      return NetworkError;
    case 400:
      return BadRequest;
    case 401:
      return Unauthorized;
    case 403:
      return Forbidden;
    case 404:
      return NotFound;
    case 409:
      return ConcurrentModification;
    case 500:
      return InternalServerError;
    case 503:
      return ServiceUnavailable;
    default:
      return undefined;
  }
}

function createError({
  statusCode,
  message,
  ...rest
}) {
  let errorMessage = message || 'Unexpected non-JSON error response';
  if (statusCode === 404) errorMessage = `URI not found: ${rest.originalRequest?.uri || rest.uri}`;
  const ResponseError = getErrorByCode(statusCode);
  if (ResponseError) return new ResponseError(errorMessage, rest);
  return new HttpError(statusCode, errorMessage, rest);
}

function predicate(retryCodes, response) {
  return !
  // retryCodes.includes(response?.error?.message) ||
  [503, ...retryCodes].includes(response?.status || response?.statusCode);
}
async function executeHttpClientRequest(fetcher, config) {
  async function sendRequest() {
    const response = await fetcher({
      ...config,
      headers: {
        ...config.headers
      }
    });

    // validations and error handlings can also be done here
    return response;
  }

  // Attempt to send the request.
  return sendRequest().catch(error => Promise.reject(error));
}
async function executor(request) {
  const {
    url,
    httpClient,
    ...rest
  } = request;
  const data = await executeHttpClientRequest(async options => {
    const {
      enableRetry,
      retryConfig
    } = rest;
    const {
      retryCodes = [],
      maxDelay = Infinity,
      maxRetries = 3,
      backoff = true,
      retryDelay = 200
    } = retryConfig || {};
    let result,
      data,
      retryCount = 0;

    // validate the `retryCodes` option
    validateRetryCodes(retryCodes);
    async function execute() {
      return httpClient(url, {
        ...rest,
        ...options,
        headers: {
          ...rest.headers,
          ...options.headers,
          // axios header encoding
          'Accept-Encoding': 'application/json'
        },
        // for axios
        ...(rest.body ? {
          data: rest.body
        } : {}),
        withCredentials: options.credentialsMode === 'include'
      });
    }
    async function executeWithRetry() {
      // first attempt
      let _response = await execute();
      if (predicate(retryCodes, _response)) return _response;

      // retry attempts
      while (enableRetry && retryCount < maxRetries) {
        retryCount++;
        _response = await execute();
        if (predicate(retryCodes, _response)) return _response;

        // delay next execution
        const timer = calculateRetryDelay({
          retryCount,
          retryDelay,
          maxRetries,
          backoff,
          maxDelay
        });
        await sleep(timer);
      }
      return _response;
    }
    const response = await executeWithRetry();
    try {
      // try to parse the `fetch` response as text
      if (response.text && typeof response.text == 'function') {
        result = await response.text();
        data = JSON.parse(result);
      } else {
        // axios response
        data = response.data || response;
      }
    } catch (err) {
      data = result;
    }
    return {
      data,
      retryCount,
      statusCode: response.status || response.statusCode || data.statusCode,
      headers: response.headers
    };
  },
  /**
   * get this object from the
   * middleware options or from
   * http client config
   */
  {});
  return data;
}

function generateID() {
  return v4();
}

function parse(headers) {
  return DEFAULT_HEADERS.reduce((result, key) => {
    let val = headers[key] ? headers[key] : typeof headers.get == 'function' ? headers.get(key) : null;
    if (val) result[key] = val;
    return result;
  }, {});
}
function getHeaders(headers) {
  if (!headers) return null;

  // node-fetch
  if (headers.raw && typeof headers.raw == 'function') return headers.raw();

  // Tmp fix for Firefox until it supports iterables
  if (!headers.forEach) return parse(headers);
  return headers.forEach((value, name) => value);
}

function isBuffer(obj) {
  return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}

function maskAuthData(request) {
  const _request = Object.assign({}, request);
  if (_request?.headers) {
    if (_request.headers.Authorization) {
      _request.headers['Authorization'] = 'Bearer ********';
    }
    if (_request.headers.authorization) {
      _request.headers['authorization'] = 'Bearer ********';
    }
  }
  return _request;
}

function mergeAuthHeader(token, req) {
  return {
    ...req,
    headers: {
      ...req.headers,
      Authorization: `Bearer ${token}`
    }
  };
}

var METHODS = ['ACL', 'BIND', 'CHECKOUT', 'CONNECT', 'COPY', 'DELETE', 'GET', 'HEAD', 'LINK', 'LOCK', 'M-SEARCH', 'MERGE', 'MKACTIVITY', 'MKCALENDAR', 'MKCOL', 'MOVE', 'NOTIFY', 'OPTIONS', 'PATCH', 'POST', 'PROPFIND', 'PROPPATCH', 'PURGE', 'PUT', 'REBIND', 'REPORT', 'SEARCH', 'SOURCE', 'SUBSCRIBE', 'TRACE', 'UNBIND', 'UNLINK', 'UNLOCK', 'UNSUBSCRIBE'];

function calculateRetryDelay({
  retryCount,
  retryDelay,
  // maxRetries,
  backoff,
  maxDelay
}) {
  if (backoff) {
    return retryCount !== 0 // do not increase if it's the first retry
    ? Math.min(Math.round((Math.random() + 1) * retryDelay * 2 ** retryCount), maxDelay) : retryDelay;
  }
  return retryDelay;
}

function sleep(ms) {
  return new Promise(resolve => {
    setTimeout(resolve, ms);
  });
}

function buildTokenCacheKey(options) {
  if (!options?.credentials?.clientId || !options.projectKey || !options.host) throw new Error('Missing required options.');
  return {
    clientId: options.credentials.clientId,
    host: options.host,
    projectKey: options.projectKey
  };
}

function calculateExpirationTime(expiresIn) {
  return Date.now() +
  // Add a gap of 5 minutes before expiration time.
  expiresIn * 1000 - 5 * 60 * 1000;
}

function store(initVal) {
  let value = initVal;
  return {
    get: TokenCacheOption => value,
    set: (val, TokenCacheOption) => {
      value = val;
    }
  };
}

function urlParser(url) {
  const object = {};
  const data = new URLSearchParams(url);
  for (let x of data.keys()) {
    if (data.getAll(x).length > 1) {
      object[x] = data.getAll(x);
    } else {
      object[x] = data.get(x);
    }
  }
  return object;
}
function urlStringifier(object) {
  const params = new URLSearchParams(object);
  for (const [key, value] of Object.entries(object)) {
    if (Array.isArray(value)) {
      params.delete(key);
      value.filter(Boolean).forEach(v => params.append(key, v));
    }
  }
  return params.toString();
}
function parseURLString(url, parser = urlParser) {
  return parser(url);
}
function stringifyURLString(object, stringifier = urlStringifier) {
  return urlStringifier(object);
}

// import { validateUserAgentOptions } from '../utils'

/*
  This is the easiest way, for this use case, to detect if we're running in
  Node.js or in a browser environment. In other cases, this won't be even a
  problem as Rollup will provide the correct polyfill in the bundle.
  The main advantage by doing it this way is that it allows to easily test
  the code running in both environments, by overriding `global.window` in
  the specific test.
*/
const isBrowser = () => typeof window !== 'undefined' && window.document && window.document.nodeType === 9;
function getSystemInfo() {
  if (isBrowser()) return window.navigator.userAgent;
  const nodeVersion = process?.version.slice(1) || 'unknow'; // unknow environment like  React Native etc
  const platformInfo = `(${process.platform}; ${process.arch})`;

  // return `node.js/${nodeVersion}`
  return `node.js/${nodeVersion} ${platformInfo}`;
}
function createUserAgent(options) {
  let libraryInfo = null;
  let contactInfo = null;

  // validateUserAgentOptions(options)
  if (!options) {
    throw new Error('Missing required option `name`');
  }

  // Main info
  const baseInfo = options.version ? `${options.name}/${options.version}` : options.name;

  // Library info
  if (options.libraryName && !options.libraryVersion) {
    libraryInfo = options.libraryName;
  } else if (options.libraryName && options.libraryVersion) {
    libraryInfo = `${options.libraryName}/${options.libraryVersion}`;
  }

  // Contact info
  if (options.contactUrl && !options.contactEmail) {
    contactInfo = `(+${options.contactUrl})`;
  } else if (!options.contactUrl && options.contactEmail) {
    contactInfo = `(+${options.contactEmail})`;
  } else if (options.contactUrl && options.contactEmail) {
    contactInfo = `(+${options.contactUrl}; +${options.contactEmail})`;
  }

  // System info
  const systemInfo = getSystemInfo();

  // customName
  const customAgent = options.customAgent || '';
  return [baseInfo, systemInfo, libraryInfo, contactInfo, customAgent].filter(Boolean).join(' ');
}

/**
 * validate some essential http options
 * @param options
 */
function validateHttpOptions(options) {
  if (!options.host) throw new Error('Request `host` or `url` is missing or invalid, please pass in a valid host e.g `host: http://a-valid-host-url`');
  if (!options.httpClient && typeof options.httpClient !== 'function') throw new Error('An `httpClient` is not available, please pass in a `fetch` or `axios` instance as an option or have them globally available.');
  if (options.timeout && !options.getAbortController) throw new Error('`AbortController` is not available. Please pass in `getAbortController` as an option or have AbortController globally available when using timeout.');
}

/**
 *
 * @param retryCodes
 * @example
 * const retryCodes = [500, 504, "ETIMEDOUT"]
 */
function validateRetryCodes(retryCodes) {
  if (!Array.isArray(retryCodes)) {
    throw new Error('`retryCodes` option must be an array of retry status (error) codes and/or messages.');
  }
}

/**
 * @param options
 */
function validateClient(options) {
  if (!options) throw new Error('Missing required options');
  if (options.middlewares && !Array.isArray(options.middlewares)) throw new Error('Middlewares should be an array');
  if (!options.middlewares || !Array.isArray(options.middlewares) || !options.middlewares.length) {
    throw new Error('You need to provide at least one middleware');
  }
}

/**
 * @param options
 */
function validate(funcName, request, options = {
  allowedMethods: METHODS
}) {
  if (!request) throw new Error(`The "${funcName}" function requires a "Request" object as an argument. See https://commercetools.github.io/nodejs/sdk/Glossary.html#clientrequest`);
  if (typeof request.uri !== 'string') throw new Error(`The "${funcName}" Request object requires a valid uri. See https://commercetools.github.io/nodejs/sdk/Glossary.html#clientrequest`);
  if (!options.allowedMethods.includes(request.method)) throw new Error(`The "${funcName}" Request object requires a valid method. See https://commercetools.github.io/nodejs/sdk/Glossary.html#clientrequest`);
}

/**
 *
 * @param {AuthMiddlewareOptions} options
 * @returns { IBuiltRequestParams } *
 */
function buildRequestForClientCredentialsFlow(options) {
  // Validate options
  if (!options) throw new Error('Missing required options');
  if (!options.host) throw new Error('Missing required option (host)');
  if (!options.projectKey) throw new Error('Missing required option (projectKey)');
  if (!options.credentials) throw new Error('Missing required option (credentials)');
  const {
    clientId,
    clientSecret
  } = options.credentials || {};
  if (!(clientId && clientSecret)) throw new Error('Missing required credentials (clientId, clientSecret)');
  const scope = options.scopes ? options.scopes.join(' ') : undefined;
  const basicAuth = Buffer.from(`${clientId}:${clientSecret}`).toString('base64');
  // This is mostly useful for internal testing purposes to be able to check
  // other oauth endpoints.
  const oauthUri = options.oauthUri || '/oauth/token';
  const url = options.host.replace(/\/$/, '') + oauthUri;
  const body = `grant_type=client_credentials${scope ? `&scope=${scope}` : ''}`;
  return {
    url,
    body,
    basicAuth
  };
}

/**
 *
 * @param {AuthMiddlewareOptions} options
 * @returns {IBuiltRequestParams} *
 */
function buildRequestForAnonymousSessionFlow(options) {
  if (!options) throw new Error('Missing required options');
  if (!options.projectKey) throw new Error('Missing required option (projectKey)');
  const projectKey = options.projectKey;
  options.oauthUri = options.oauthUri || `/oauth/${projectKey}/anonymous/token`;
  const result = buildRequestForClientCredentialsFlow(options);
  if (options.credentials.anonymousId) result.body += `&anonymous_id=${options.credentials.anonymousId}`;
  return {
    ...result
  };
}

/**
 *
 * @param {RefreshAuthMiddlewareOptions} options
 * @returns {IBuiltRequestParams}
 */
function buildRequestForRefreshTokenFlow(options) {
  if (!options) throw new Error('Missing required options');
  if (!options.host) throw new Error('Missing required option (host)');
  if (!options.projectKey) throw new Error('Missing required option (projectKey)');
  if (!options.credentials) throw new Error('Missing required option (credentials)');
  if (!options.refreshToken) throw new Error('Missing required option (refreshToken)');
  const {
    clientId,
    clientSecret
  } = options.credentials;
  if (!(clientId && clientSecret)) throw new Error('Missing required credentials (clientId, clientSecret)');
  const basicAuth = Buffer.from(`${clientId}:${clientSecret}`).toString('base64');
  // This is mostly useful for internal testing purposes to be able to check
  // other oauth endpoints.
  const oauthUri = options.oauthUri || '/oauth/token';
  const url = options.host.replace(/\/$/, '') + oauthUri;
  const body = `grant_type=refresh_token&refresh_token=${encodeURIComponent(options.refreshToken)}`;
  return {
    basicAuth,
    url,
    body
  };
}

/**
 * @param {PasswordAuthMiddlewareOptions} options
 * @returns {IBuiltRequestParams}
 */
function buildRequestForPasswordFlow(options) {
  if (!options) throw new Error('Missing required options');
  if (!options.host) throw new Error('Missing required option (host)');
  if (!options.projectKey) throw new Error('Missing required option (projectKey)');
  if (!options.credentials) throw new Error('Missing required option (credentials)');
  const {
    clientId,
    clientSecret,
    user
  } = options.credentials;
  const projectKey = options.projectKey;
  if (!(clientId && clientSecret && user)) throw new Error('Missing required credentials (clientId, clientSecret, user)');
  const {
    username,
    password
  } = user;
  if (!(username && password)) throw new Error('Missing required user credentials (username, password)');
  const scope = (options.scopes || []).join(' ');
  const scopeStr = scope ? `&scope=${scope}` : '';
  const basicAuth = Buffer.from(`${clientId}:${clientSecret}`).toString('base64');

  /**
   * This is mostly useful for internal testing purposes to be able to check
   * other oauth endpoints.
   */
  const oauthUri = options.oauthUri || `/oauth/${projectKey}/customers/token`;
  const url = options.host.replace(/\/$/, '') + oauthUri;

  // encode username and password as requested by the system
  const body = `grant_type=password&username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}${scopeStr}`;
  return {
    basicAuth,
    url,
    body
  };
}

async function executeRequest$1(options) {
  const {
    request,
    httpClient,
    tokenCache,
    tokenCacheKey,
    requestState,
    userOption,
    next
  } = options;
  let url = options.url;
  let body = options.body;
  let basicAuth = options.basicAuth;

  // get the pending object from option
  let pendingTasks = options.pendingTasks;
  if (!httpClient || typeof httpClient !== 'function') throw new Error('an `httpClient` is not available, please pass in a `fetch` or `axios` instance as an option or have them globally available.');

  /**
   * If there is a token in the tokenCache, and it's not
   * expired, append the token in the `Authorization` header.
   */
  const tokenCacheObject = tokenCache.get(tokenCacheKey);
  if (tokenCacheObject && tokenCacheObject.token && Date.now() < tokenCacheObject.expirationTime) {
    const requestWithAuth = mergeAuthHeader(tokenCacheObject.token, request);
    return {
      ...requestWithAuth
    };
  }

  /**
   * Keep pending tasks until a token is fetched
   * Save next function as well, to call it once the token has been fetched, which prevents
   * unexpected behaviour in a context in which the next function uses global vars
   * or Promises to capture the token to hand it to other libraries, e.g. Apollo
   */
  pendingTasks.push({
    request,
    next
  });

  // if a token is currently being fetched, then wait
  if (requestState.get()) return;

  // signal that a token is being fetched
  requestState.set(true);

  /**
   * use refreshToken flow if there is refresh-token
   * and there's either no token or the token is expired
   */
  if (tokenCacheObject && tokenCacheObject.refreshToken && (!tokenCacheObject.token || tokenCacheObject.token && Date.now() > tokenCacheObject.expirationTime)) {
    if (!userOption) throw new Error('Missing required options.');
    const opt = {
      ...buildRequestForRefreshTokenFlow({
        ...userOption,
        refreshToken: tokenCacheObject.refreshToken
      })
    };

    // reassign values
    url = opt.url;
    body = opt.body;
    basicAuth = opt.basicAuth;
  }

  // request a new token
  let response;
  try {
    response = await executor({
      url,
      method: 'POST',
      headers: {
        Authorization: `Basic ${basicAuth}`,
        'Content-Type': 'application/x-www-form-urlencoded',
        'Conent-Length': Buffer.byteLength(body).toString()
      },
      httpClient,
      body
    });
    if (response.statusCode >= 200 && response.statusCode < 300) {
      const {
        access_token: token,
        expires_in: expiresIn,
        refresh_token: refreshToken
      } = response?.data;

      // calculate token expiration time
      const expirationTime = calculateExpirationTime(expiresIn);

      // cache new generated token, refreshToken and expiration time
      tokenCache.set({
        token,
        expirationTime,
        refreshToken
      });

      // signal that a token fetch is complete
      requestState.set(false);

      /**
       * Freeze and copy pending queue, reset
       * original one for accepting new pending tasks
       */
      const requestQueue = pendingTasks.slice();

      // reset pendingTask queue
      pendingTasks = [];
      if (requestQueue.length === 1) {
        return mergeAuthHeader(token, requestQueue.pop().request);
      }

      // execute all pending tasks if any
      for (let i = 0; i < requestQueue.length; i++) {
        const task = requestQueue[i];
        const requestWithAuth = mergeAuthHeader(token, task.request);

        // execute task
        task.next(requestWithAuth);
      }
      return;
    }
    const error = new Error(response.data.message ? response.data.message : JSON.stringify(response.data));
    /**
     * reject the error immediately
     * and free up the middleware chain
     */
    request.reject({
      ...request,
      headers: {
        ...request.headers
      },
      response: {
        statusCode: response.statusCode || response.data.statusCode,
        error: {
          error,
          body: response
        }
      }
    });
  } catch (error) {
    return {
      ...request,
      headers: {
        ...request.headers
      },
      response: {
        body: null,
        statusCode: error.statusCode || 0,
        error: {
          ...response,
          error,
          body: response
        }
      }
    };
  }
}

function createAuthMiddlewareForAnonymousSessionFlow$1(options) {
  const pendingTasks = [];
  const requestState = store(false);
  const tokenCache = options.tokenCache || store({
    token: '',
    expirationTime: -1
  });
  const tokenCacheKey = buildTokenCacheKey(options);
  return next => {
    return async request => {
      // if here is a token in the header, then move on to the next middleware
      if (request.headers && (request.headers.Authorization || request.headers.authorization)) {
        // move on
        return next(request);
      }

      // prepare request options
      const requestOptions = {
        request,
        requestState,
        tokenCache,
        pendingTasks,
        tokenCacheKey,
        httpClient: options.httpClient || fetch$1,
        ...buildRequestForAnonymousSessionFlow(options),
        userOption: options,
        next
      };

      // make request to coco
      const requestWithAuth = await executeRequest$1(requestOptions);
      if (requestWithAuth) {
        return next(requestWithAuth);
      }
    };
  };
}

function createAuthMiddlewareForClientCredentialsFlow$1(options) {
  const requestState = store(false);
  const pendingTasks = [];
  const tokenCache = options.tokenCache || store({
    token: '',
    expirationTime: -1
  });
  const tokenCacheKey = buildTokenCacheKey(options);
  return next => {
    return async request => {
      // if here is a token in the header, then move on to the next middleware
      if (request.headers && (request.headers.Authorization || request.headers.authorization)) {
        // move on
        return next(request);
      }

      // prepare request options
      const requestOptions = {
        request,
        requestState,
        tokenCache,
        pendingTasks,
        tokenCacheKey,
        httpClient: options.httpClient || fetch$1,
        ...buildRequestForClientCredentialsFlow(options),
        next
      };

      // make request to coco
      const requestWithAuth = await executeRequest$1(requestOptions);
      if (requestWithAuth) {
        // make the request and inject the token into the header
        return next(requestWithAuth);
      }
    };
  };
}

function createAuthMiddlewareForExistingTokenFlow$1(authorization, options) {
  return next => {
    return async request => {
      if (typeof authorization !== 'string') throw new Error('authorization must be a string');
      const isForce = options?.force === undefined ? true : options.force;

      /**
       * The request will not be modified if:
       *  1. no argument is passed
       *  2. force is false and authorization header exists
       */
      if (!authorization || request.headers && (request.headers.Authorization || request.headers.authorization) && isForce === false) {
        return next(request);
      }
      const requestWithAuth = {
        ...request,
        headers: {
          ...request.headers,
          Authorization: authorization
        }
      };
      return next(requestWithAuth);
    };
  };
}

function createAuthMiddlewareForPasswordFlow$1(options) {
  const tokenCache = options.tokenCache || store({
    token: '',
    expirationTime: -1
  });
  const pendingTasks = [];
  const requestState = store(false);
  const tokenCacheKey = buildTokenCacheKey(options);
  return next => {
    return async request => {
      if (request.headers && (request.headers.Authorization || request.headers.authorization)) {
        return next(request);
      }
      const requestOptions = {
        request,
        requestState,
        tokenCache,
        pendingTasks,
        tokenCacheKey,
        httpClient: options.httpClient || fetch$1,
        ...buildRequestForPasswordFlow(options),
        userOption: options,
        next
      };

      // make request to coco
      const requestWithAuth = await executeRequest$1(requestOptions);
      if (requestWithAuth) {
        return next(requestWithAuth);
      }
    };
  };
}

function createAuthMiddlewareForRefreshTokenFlow$1(options) {
  const tokenCache = options.tokenCache || store({
    token: '',
    tokenCacheKey: null
  });
  const pendingTasks = [];
  const requestState = store(false);
  return next => {
    return async request => {
      if (request.headers && (request.headers.Authorization || request.headers.authorization)) {
        return next(request);
      }

      // prepare request options
      const requestOptions = {
        request,
        requestState,
        tokenCache,
        pendingTasks,
        httpClient: options.httpClient || fetch,
        ...buildRequestForRefreshTokenFlow(options),
        next
      };

      // make request to coco
      const requestWithAuth = await executeRequest$1(requestOptions);
      if (requestWithAuth) {
        return next(requestWithAuth);
      }
    };
  };
}

function createConcurrentModificationMiddleware$1() {
  return next => {
    return async request => {
      const response = await next(request);
      if (response.statusCode == 409) {
        /**
         * extract the currentVersion
         * from the error body and update
         * request with the currentVersion
         */
        const version = response.error.body?.errors?.[0]?.currentVersion;

        // update the resource version here
        if (version) {
          request.body = typeof request.body == 'string' ? {
            ...JSON.parse(request.body),
            version
          } : {
            ...request.body,
            version
          };
          return next(request);
        }
      }
      return response;
    };
  };
}

function createCorrelationIdMiddleware$1(options) {
  return next => request => {
    const nextRequest = {
      ...request,
      headers: {
        ...request.headers,
        'X-Correlation-ID': options.generate && typeof options.generate == 'function' ? options.generate() : generateID()
      }
    };
    return next(nextRequest);
  };
}

function createErrorMiddleware$1(options) {
  return next => async request => {
    const response = await next(request);
    if (response.error) {
      const {
        error
      } = response;
      return {
        ...response,
        statusCode: error.statusCode || 0,
        headers: error.headers || getHeaders({}),
        error: {
          ...error,
          body: error.data || error
        }
      };
    }
    return response;
  };
}

async function executeRequest({
  url,
  httpClient,
  clientOptions
}) {
  let timer;
  const {
    timeout,
    request,
    abortController,
    maskSensitiveHeaderData,
    includeRequestInErrorResponse
  } = clientOptions;
  try {
    if (timeout) timer = setTimeout(() => {
      abortController.abort();
    }, timeout);
    const response = await executor({
      url,
      ...clientOptions,
      httpClient,
      method: clientOptions.method,
      ...(clientOptions.body ? {
        body: clientOptions.body
      } : {})
    });
    if (response.statusCode >= 200 && response.statusCode < 300) {
      if (clientOptions.method == 'HEAD') {
        return {
          body: null,
          statusCode: response.statusCode,
          retryCount: response.retryCount,
          headers: getHeaders(response.headers)
        };
      }
      return {
        body: response.data,
        statusCode: response.statusCode,
        retryCount: response.retryCount,
        headers: getHeaders(response.headers)
      };
    }
    const error = createError({
      message: response?.data?.message || response?.message,
      statusCode: response.statusCode || response?.data?.statusCode,
      headers: getHeaders(response.headers),
      method: clientOptions.method,
      body: response.data,
      retryCount: response.retryCount,
      ...(includeRequestInErrorResponse ? {
        originalRequest: maskSensitiveHeaderData ? maskAuthData(request) : request
      } : {
        uri: request.uri
      })
    });

    /**
     * handle non-ok (error) response
     * build error body
     */
    return {
      body: response.data,
      code: response.statusCode,
      statusCode: response.statusCode,
      headers: getHeaders(response.headers),
      error
    };
  } catch (e) {
    // We know that this is a network error
    const headers = getHeaders(e.response?.headers);
    const statusCode = e.response?.status || e.response?.data0 || 0;
    const message = e.response?.data?.message;
    const error = createError({
      statusCode,
      code: statusCode,
      status: statusCode,
      message: message || e.message,
      headers,
      body: e.response?.data || e,
      error: e.response?.data,
      ...(includeRequestInErrorResponse ? {
        originalRequest: maskSensitiveHeaderData ? maskAuthData(request) : request
      } : {
        uri: request.uri
      })
    });
    return {
      body: error,
      error
    };
  } finally {
    clearTimeout(timer);
  }
}
function createHttpMiddleware$1(options) {
  // validate response
  validateHttpOptions(options);
  const {
    host,
    credentialsMode,
    httpClient,
    timeout,
    enableRetry,
    retryConfig,
    getAbortController,
    includeOriginalRequest,
    includeRequestInErrorResponse,
    maskSensitiveHeaderData,
    httpClientOptions
  } = options;
  return next => {
    return async request => {
      let abortController;
      if (timeout || getAbortController) abortController = (getAbortController ? getAbortController() : null) || new AbortController();
      const url = host.replace(/\/$/, '') + request.uri;
      const requestHeader = {
        ...request.headers
      };

      // validate header
      if (!(Object.prototype.hasOwnProperty.call(requestHeader, 'Content-Type') || Object.prototype.hasOwnProperty.call(requestHeader, 'content-type'))) {
        requestHeader['Content-Type'] = 'application/json';
      }

      // Unset the content-type header if explicitly asked to (passing `null` as value).
      if (requestHeader['Content-Type'] === null) {
        delete requestHeader['Content-Type'];
      }

      // Ensure body is a string if content type is application/{json|graphql}
      const body = HEADERS_CONTENT_TYPES.indexOf(requestHeader['Content-Type']) > -1 && typeof request.body === 'string' || isBuffer(request.body) ? request.body : JSON.stringify(request.body || undefined);
      if (body && (typeof body === 'string' || isBuffer(body))) {
        requestHeader['Content-Length'] = Buffer.byteLength(body).toString();
      }
      const clientOptions = {
        enableRetry,
        retryConfig,
        request: request,
        method: request.method,
        headers: requestHeader,
        includeRequestInErrorResponse,
        maskSensitiveHeaderData,
        ...httpClientOptions
      };
      if (credentialsMode) {
        clientOptions.credentialsMode = credentialsMode;
      }
      if (abortController) {
        clientOptions.signal = abortController.signal;
      }
      if (timeout) {
        clientOptions.timeout = timeout;
        clientOptions.abortController = abortController;
      }
      if (body) {
        clientOptions.body = body;
      }

      // get result from executed request
      const response = await executeRequest({
        url,
        clientOptions,
        httpClient
      });
      const responseWithRequest = {
        ...request,
        includeOriginalRequest,
        maskSensitiveHeaderData,
        response
      };
      return next(responseWithRequest);
    };
  };
}

// error, info, success
function createLoggerMiddleware$1(options) {
  return next => {
    return async request => {
      let response = await next(request);
      const originalResponse = Object.assign({}, response);
      const {
        loggerFn = console.log,
        // logLevel = 'ERROR',
        maskSensitiveHeaderData = true,
        includeOriginalRequest = true,
        includeResponseHeaders = true
        // includeRequestInErrorResponse
      } = options || {};
      if (includeOriginalRequest && maskSensitiveHeaderData) {
        maskAuthData(response.request);
      }
      if (!includeOriginalRequest) {
        const {
          request,
          ...rest
        } = response;
        response = rest;
      }
      if (!includeResponseHeaders) {
        const {
          headers,
          ...rest
        } = response;
        response = rest;
      }
      if (loggerFn && typeof loggerFn == 'function') {
        loggerFn(response);
        // return originalResponse
      }

      // console.log({ Response: response })
      return originalResponse;
    };
  };
}

function createQueueMiddleware$1({
  concurrency = 20
}) {
  let runningCount = 0;
  const queue = [];
  const dequeue = next => {
    runningCount--;
    if (queue.length && runningCount <= concurrency) {
      const nextTask = queue.shift();
      runningCount++;
      return next(nextTask.request);
    }
  };
  const enqueue = ({
    request
  }) => queue.push({
    request
  });
  return next => request => {
    // wrap and override resolve and reject functions
    const patchedRequest = {
      ...request,
      resolve(data) {
        request.resolve(data);
        dequeue(next);
      },
      reject(error) {
        request.reject(error);
        dequeue(next);
      }
    };

    // enqueue requests
    enqueue({
      request: patchedRequest
    });
    if (runningCount < concurrency) {
      runningCount++;
      const nextTask = queue.shift();
      return next(nextTask.request);
    }
  };
}

var packageJson = {
	name: "@commercetools/ts-client",
	version: "1.1.1",
	engines: {
		node: ">=14"
	},
	description: "commercetools Composable Commerce TypeScript SDK client.",
	keywords: [
		"commercetools",
		"composable commerce",
		"sdk",
		"typescript",
		"client",
		"middleware",
		"http",
		"oauth",
		"auth"
	],
	homepage: "https://github.com/commercetools/commercetools-sdk-typescript",
	license: "MIT",
	directories: {
		lib: "lib",
		test: "test"
	},
	publishConfig: {
		access: "public"
	},
	repository: {
		type: "git",
		url: "git+https://github.com/commercetools/commercetools-sdk-typescript.git"
	},
	bugs: {
		url: "https://github.com/commercetools/commercetools-sdk-typescript/issues"
	},
	dependencies: {
		"abort-controller": "3.0.0",
		buffer: "^6.0.3",
		"node-fetch": "^2.6.1",
		uuid: "9.0.0"
	},
	files: [
		"dist",
		"CHANGELOG.md"
	],
	author: "Chukwuemeka Ajima <meeky.ae@gmail.com>",
	main: "dist/commercetools-ts-client.cjs.js",
	module: "dist/commercetools-ts-client.esm.js",
	browser: {
		"./dist/commercetools-ts-client.cjs.js": "./dist/commercetools-ts-client.browser.cjs.js",
		"./dist/commercetools-ts-client.esm.js": "./dist/commercetools-ts-client.browser.esm.js"
	},
	devDependencies: {
		"common-tags": "1.8.2",
		dotenv: "16.3.1",
		jest: "29.6.2",
		nock: "12.0.3",
		"organize-imports-cli": "0.10.0"
	},
	scripts: {
		organize_imports: "find src -type f -name '*.ts' | xargs organize-imports-cli",
		postbuild: "yarn organize_imports",
		post_process_generate: "yarn organize_imports"
	}
};

function createUserAgentMiddleware$1(options) {
  return next => async request => {
    const userAgent = createUserAgent({
      ...options,
      name: `commercetools-sdk-javascript-v3/${packageJson.version}`
    });
    const requestWithUserAgent = {
      ...request,
      headers: {
        ...request.headers,
        'User-Agent': userAgent
      }
    };
    return next(requestWithUserAgent);
  };
}

var middleware = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createAuthMiddlewareForAnonymousSessionFlow: createAuthMiddlewareForAnonymousSessionFlow$1,
  createAuthMiddlewareForClientCredentialsFlow: createAuthMiddlewareForClientCredentialsFlow$1,
  createAuthMiddlewareForExistingTokenFlow: createAuthMiddlewareForExistingTokenFlow$1,
  createAuthMiddlewareForPasswordFlow: createAuthMiddlewareForPasswordFlow$1,
  createAuthMiddlewareForRefreshTokenFlow: createAuthMiddlewareForRefreshTokenFlow$1,
  createConcurrentModificationMiddleware: createConcurrentModificationMiddleware$1,
  createCorrelationIdMiddleware: createCorrelationIdMiddleware$1,
  createErrorMiddleware: createErrorMiddleware$1,
  createHttpMiddleware: createHttpMiddleware$1,
  createLoggerMiddleware: createLoggerMiddleware$1,
  createQueueMiddleware: createQueueMiddleware$1,
  createUserAgentMiddleware: createUserAgentMiddleware$1
});

function compose({
  middlewares
}) {
  if (middlewares.length === 1) return middlewares[0];
  const _middlewares = middlewares.slice();
  return _middlewares.reduce((ac, cv) => (...args) => ac(cv.apply(null, args)));
}

// process batch requests
let _options;
function process$1(request, fn, processOpt) {
  validate('process', request, {
    allowedMethods: ['GET']
  });
  if (typeof fn !== 'function') throw new Error('The "process" function accepts a "Function" as a second argument that returns a Promise. See https://commercetools.github.io/nodejs/sdk/api/sdkClient.html#processrequest-processfn-options');

  // Set default process options
  const opt = {
    total: Number.POSITIVE_INFINITY,
    accumulate: true,
    ...processOpt
  };
  return new Promise((resolve, reject) => {
    let _path,
      _queryString = '';
    if (request && request.uri) {
      const [path, queryString] = request.uri.split('?');
      _path = path;
      _queryString = queryString;
    }
    const requestQuery = {
      ...parseURLString(_queryString)
    };
    const query = {
      // defaults
      limit: 20,
      // merge given query params
      ...requestQuery
    };
    let itemsToGet = opt.total;
    let hasFirstPageBeenProcessed = false;
    const processPage = async (lastId, acc = []) => {
      // Use the lesser value between limit and itemsToGet in query
      const limit = query.limit < itemsToGet ? query.limit : itemsToGet;
      const originalQueryString = stringifyURLString({
        ...query,
        limit
      });
      const enhancedQuery = {
        sort: 'id asc',
        withTotal: false,
        ...(lastId ? {
          where: `id > "${lastId}"`
        } : {})
      };
      const enhancedQueryString = stringifyURLString(enhancedQuery);
      const enhancedRequest = {
        ...request,
        uri: `${_path}?${enhancedQueryString}&${originalQueryString}`
      };
      try {
        const payload = await createClient(_options).execute(enhancedRequest);
        const {
          results,
          count: resultsLength
        } = payload?.body || {};
        if (!resultsLength && hasFirstPageBeenProcessed) {
          return resolve(acc || []);
        }
        const result = await Promise.resolve(fn(payload));
        let accumulated;
        hasFirstPageBeenProcessed = true;
        if (opt.accumulate) accumulated = acc.concat(result || []);
        itemsToGet -= resultsLength;
        // If there are no more items to get, it means the total number
        // of items in the original request have been fetched so we
        // resolve the promise.
        // Also, if we get less results in a page then the limit set it
        // means that there are no more pages and that we can finally
        // resolve the promise.
        if (resultsLength < query.limit || !itemsToGet) {
          return resolve(accumulated || []);
        }
        const last = results[resultsLength - 1];
        const newLastId = last && last.id;
        processPage(newLastId, accumulated);
      } catch (error) {
        reject(error);
      }
    };

    // Start iterating through pages
    processPage();
  });
}
function createClient(middlewares) {
  _options = middlewares;
  validateClient(middlewares);
  const resolver = {
    async resolve(rs) {
      const {
        response,
        includeOriginalRequest,
        maskSensitiveHeaderData,
        ...request
      } = rs;
      const {
        retryCount,
        ...rest
      } = response;
      const res = {
        body: null,
        error: null,
        reject: rs.reject,
        resolve: rs.resolve,
        ...rest,
        ...(includeOriginalRequest ? {
          originalRequest: maskSensitiveHeaderData ? maskAuthData(request) : request
        } : {}),
        ...(response?.retryCount ? {
          retryCount: response.retryCount
        } : {})
      };
      return res;
    }
  };
  const dispatch = compose(middlewares)(resolver.resolve);
  return {
    process: process$1,
    execute(request) {
      validate('exec', request);
      return new Promise((resolve, reject) => {
        dispatch({
          reject,
          resolve,
          ...request
        }).then(resolve).catch(reject);
      });
    }
  };
}

const {
  createAuthMiddlewareForPasswordFlow,
  createAuthMiddlewareForAnonymousSessionFlow,
  createAuthMiddlewareForClientCredentialsFlow,
  createAuthMiddlewareForRefreshTokenFlow,
  createAuthMiddlewareForExistingTokenFlow,
  createCorrelationIdMiddleware,
  createHttpMiddleware,
  createLoggerMiddleware,
  createQueueMiddleware,
  createUserAgentMiddleware,
  createConcurrentModificationMiddleware,
  createErrorMiddleware
} = middleware;
class ClientBuilder {
  constructor() {
    _defineProperty(this, "projectKey", void 0);
    _defineProperty(this, "authMiddleware", void 0);
    _defineProperty(this, "httpMiddleware", void 0);
    _defineProperty(this, "userAgentMiddleware", void 0);
    _defineProperty(this, "correlationIdMiddleware", void 0);
    _defineProperty(this, "loggerMiddleware", void 0);
    _defineProperty(this, "queueMiddleware", void 0);
    _defineProperty(this, "concurrentMiddleware", void 0);
    _defineProperty(this, "errorMiddleware", void 0);
    _defineProperty(this, "middlewares", []);
    this.userAgentMiddleware = createUserAgentMiddleware({});
  }
  withProjectKey(key) {
    this.projectKey = key;
    return this;
  }
  defaultClient(baseUri, credentials, oauthUri, projectKey, scopes, httpClient) {
    return this.withClientCredentialsFlow({
      host: oauthUri,
      projectKey: projectKey || this.projectKey,
      credentials,
      scopes
    }).withHttpMiddleware({
      host: baseUri,
      httpClient: httpClient || fetch$1
    });
  }
  withAuthMiddleware(authMiddleware) {
    this.authMiddleware = authMiddleware;
    return this;
  }
  withMiddleware(middleware) {
    this.middlewares.push(middleware);
    return this;
  }
  withClientCredentialsFlow(options) {
    return this.withAuthMiddleware(createAuthMiddlewareForClientCredentialsFlow({
      host: options.host || CTP_AUTH_URL,
      projectKey: options.projectKey || this.projectKey,
      credentials: {
        clientId: options.credentials.clientId || null,
        clientSecret: options.credentials.clientSecret || null
      },
      oauthUri: options.oauthUri || null,
      scopes: options.scopes,
      httpClient: options.httpClient || fetch$1,
      ...options
    }));
  }
  withPasswordFlow(options) {
    return this.withAuthMiddleware(createAuthMiddlewareForPasswordFlow({
      host: options.host || CTP_AUTH_URL,
      projectKey: options.projectKey || this.projectKey,
      credentials: {
        clientId: options.credentials.clientId || null,
        clientSecret: options.credentials.clientSecret || null,
        user: {
          username: options.credentials.user.username || null,
          password: options.credentials.user.password || null
        }
      },
      httpClient: options.httpClient || fetch$1,
      ...options
    }));
  }
  withAnonymousSessionFlow(options) {
    return this.withAuthMiddleware(createAuthMiddlewareForAnonymousSessionFlow({
      host: options.host || CTP_AUTH_URL,
      projectKey: this.projectKey || options.projectKey,
      credentials: {
        clientId: options.credentials.clientId || null,
        clientSecret: options.credentials.clientSecret || null,
        anonymousId: options.credentials.anonymousId || null
      },
      httpClient: options.httpClient || fetch$1,
      ...options
    }));
  }
  withRefreshTokenFlow(options) {
    return this.withAuthMiddleware(createAuthMiddlewareForRefreshTokenFlow({
      host: options.host || CTP_AUTH_URL,
      projectKey: this.projectKey || options.projectKey,
      credentials: {
        clientId: options.credentials.clientId || null,
        clientSecret: options.credentials.clientSecret || null
      },
      httpClient: options.httpClient || fetch$1,
      refreshToken: options.refreshToken || null,
      ...options
    }));
  }
  withExistingTokenFlow(authorization, options) {
    return this.withAuthMiddleware(createAuthMiddlewareForExistingTokenFlow(authorization, {
      force: options.force || true,
      ...options
    }));
  }
  withHttpMiddleware(options) {
    this.httpMiddleware = createHttpMiddleware({
      host: options.host || CTP_API_URL,
      httpClient: options.httpClient || fetch$1,
      ...options
    });
    return this;
  }
  withUserAgentMiddleware(options) {
    this.userAgentMiddleware = createUserAgentMiddleware(options);
    return this;
  }
  withQueueMiddleware(options) {
    this.queueMiddleware = createQueueMiddleware({
      concurrency: options.concurrency || CONCURRENCT_REQUEST,
      ...options
    });
    return this;
  }
  withLoggerMiddleware(options) {
    this.loggerMiddleware = createLoggerMiddleware(options);
    return this;
  }
  withCorrelationIdMiddleware(options) {
    this.correlationIdMiddleware = createCorrelationIdMiddleware({
      generate: options?.generate,
      ...options
    });
    return this;
  }
  withConcurrentModificationMiddleware() {
    this.concurrentMiddleware = createConcurrentModificationMiddleware();
    return this;
  }
  withErrorMiddleware(options) {
    this.errorMiddleware = createErrorMiddleware(options);
    return this;
  }
  build() {
    const middlewares = this.middlewares.slice();

    /**
     * - use default retry policy if not explicity added
     * - add retry middleware to be used by concurrent modification
     *   middleware if not explicitly added as part of the middleware
     */
    if (this.correlationIdMiddleware) middlewares.push(this.correlationIdMiddleware);
    if (this.userAgentMiddleware) middlewares.push(this.userAgentMiddleware);
    if (this.authMiddleware) middlewares.push(this.authMiddleware);
    if (this.queueMiddleware) middlewares.push(this.queueMiddleware);
    if (this.loggerMiddleware) middlewares.push(this.loggerMiddleware);
    if (this.errorMiddleware) middlewares.push(this.errorMiddleware);
    if (this.concurrentMiddleware) middlewares.push(this.concurrentMiddleware);
    if (this.httpMiddleware) middlewares.push(this.httpMiddleware);
    return createClient({
      middlewares
    });
  }
}

export { ClientBuilder, process$1 as Process, createAuthMiddlewareForAnonymousSessionFlow$1 as createAuthMiddlewareForAnonymousSessionFlow, createAuthMiddlewareForClientCredentialsFlow$1 as createAuthMiddlewareForClientCredentialsFlow, createAuthMiddlewareForExistingTokenFlow$1 as createAuthMiddlewareForExistingTokenFlow, createAuthMiddlewareForPasswordFlow$1 as createAuthMiddlewareForPasswordFlow, createAuthMiddlewareForRefreshTokenFlow$1 as createAuthMiddlewareForRefreshTokenFlow, createClient, createConcurrentModificationMiddleware$1 as createConcurrentModificationMiddleware, createCorrelationIdMiddleware$1 as createCorrelationIdMiddleware, createHttpMiddleware$1 as createHttpMiddleware, createLoggerMiddleware$1 as createLoggerMiddleware, createQueueMiddleware$1 as createQueueMiddleware, createUserAgentMiddleware$1 as createUserAgentMiddleware };
