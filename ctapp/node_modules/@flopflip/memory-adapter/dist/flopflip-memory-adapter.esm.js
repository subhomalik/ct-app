import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';
import _classPrivateFieldLooseBase from '@babel/runtime/helpers/esm/classPrivateFieldLooseBase';
import _classPrivateFieldLooseKey from '@babel/runtime/helpers/esm/classPrivateFieldLooseKey';
import { exposeGlobally, normalizeFlag } from '@flopflip/adapter-utilities';
import { AdapterConfigurationStatus, AdapterSubscriptionStatus, adapterIdentifiers, AdapterInitializationStatus } from '@flopflip/types';
import mitt from 'mitt';
import warning from 'tiny-warning';

const intialAdapterState = {
  configurationStatus: AdapterConfigurationStatus.Unconfigured,
  subscriptionStatus: AdapterSubscriptionStatus.Subscribed,
  flags: {},
  lockedFlags: new Set(),
  user: {},
  emitter: mitt()
};
var _internalConfiguredStatusChange__ = /*#__PURE__*/_classPrivateFieldLooseKey("__internalConfiguredStatusChange__");
var _adapterState = /*#__PURE__*/_classPrivateFieldLooseKey("adapterState");
var _getIsAdapterUnsubscribed = /*#__PURE__*/_classPrivateFieldLooseKey("getIsAdapterUnsubscribed");
var _getIsFlagLocked = /*#__PURE__*/_classPrivateFieldLooseKey("getIsFlagLocked");
var _updateUser = /*#__PURE__*/_classPrivateFieldLooseKey("updateUser");
class MemoryAdapter {
  constructor() {
    this.id = void 0;
    // eslint-disable-next-line @typescript-eslint/prefer-readonly
    Object.defineProperty(this, _internalConfiguredStatusChange__, {
      writable: true,
      value: '__internalConfiguredStatusChange__'
    });
    Object.defineProperty(this, _adapterState, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _getIsAdapterUnsubscribed, {
      writable: true,
      value: () => _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].subscriptionStatus === AdapterSubscriptionStatus.Unsubscribed
    });
    Object.defineProperty(this, _getIsFlagLocked, {
      writable: true,
      value: flagName => _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].lockedFlags.has(flagName)
    });
    Object.defineProperty(this, _updateUser, {
      writable: true,
      value: user => {
        _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].user = user;
      }
    });
    this.getUser = () => _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].user;
    this.updateFlags = (flags, options) => {
      const isAdapterConfigured = this.getIsConfigurationStatus(AdapterConfigurationStatus.Configured);
      warning(isAdapterConfigured, '@flopflip/memory-adapter: adapter is not configured. Flags can not be updated before.');
      if (!isAdapterConfigured) return;
      Object.entries(flags).forEach(_ref => {
        let _ref2 = _slicedToArray(_ref, 2),
          flagName = _ref2[0],
          flagValue = _ref2[1];
        const _normalizeFlag = normalizeFlag(flagName, flagValue),
          _normalizeFlag2 = _slicedToArray(_normalizeFlag, 2),
          normalizedFlagName = _normalizeFlag2[0],
          normalizedFlagValue = _normalizeFlag2[1];
        if (_classPrivateFieldLooseBase(this, _getIsFlagLocked)[_getIsFlagLocked](normalizedFlagName)) return;
        if (options !== null && options !== void 0 && options.lockFlags) {
          _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].lockedFlags.add(normalizedFlagName);
        }
        _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].flags = _objectSpread(_objectSpread({}, _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].flags), {}, {
          [normalizedFlagName]: normalizedFlagValue
        });
      });
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit('flagsStateChange', _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].flags);
    };
    this.reset = () => {
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState] = _objectSpread({}, intialAdapterState);
    };
    this.unsubscribe = () => {
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].subscriptionStatus = AdapterSubscriptionStatus.Unsubscribed;
    };
    this.subscribe = () => {
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].subscriptionStatus = AdapterSubscriptionStatus.Subscribed;
    };
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState] = _objectSpread({}, intialAdapterState);
    this.id = adapterIdentifiers.memory;
  }
  async configure(adapterArgs, adapterEventHandlers) {
    const handleFlagsChange = nextFlags => {
      if (_classPrivateFieldLooseBase(this, _getIsAdapterUnsubscribed)[_getIsAdapterUnsubscribed]()) return;
      adapterEventHandlers.onFlagsStateChange({
        flags: nextFlags,
        id: this.id
      });
    };
    const handleStatusChange = nextStatus => {
      if (_classPrivateFieldLooseBase(this, _getIsAdapterUnsubscribed)[_getIsAdapterUnsubscribed]()) return;
      adapterEventHandlers.onStatusStateChange({
        status: nextStatus,
        id: this.id
      });
    };
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.on('flagsStateChange', handleFlagsChange);
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.on('statusStateChange', handleStatusChange);
    this.setConfigurationStatus(AdapterConfigurationStatus.Configuring);
    const user = adapterArgs.user;
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].user = user;
    return Promise.resolve().then(() => {
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].flags = {};
      _classPrivateFieldLooseBase(this, _updateUser)[_updateUser](user);
      this.setConfigurationStatus(AdapterConfigurationStatus.Configured);
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit('flagsStateChange', _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].flags);
      _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit(_classPrivateFieldLooseBase(this, _internalConfiguredStatusChange__)[_internalConfiguredStatusChange__]);
      return {
        initializationStatus: AdapterInitializationStatus.Succeeded
      };
    });
  }
  async reconfigure(adapterArgs, _adapterEventHandlers) {
    this.setConfigurationStatus(AdapterConfigurationStatus.Configuring);
    _classPrivateFieldLooseBase(this, _updateUser)[_updateUser](adapterArgs.user);
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].flags = {};
    this.setConfigurationStatus(AdapterConfigurationStatus.Configured);
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit('flagsStateChange', _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].flags);
    return Promise.resolve({
      initializationStatus: AdapterInitializationStatus.Succeeded
    });
  }
  getIsConfigurationStatus(configurationStatus) {
    return _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].configurationStatus === configurationStatus;
  }
  setConfigurationStatus(nextConfigurationStatus) {
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].configurationStatus = nextConfigurationStatus;
    _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.emit('statusStateChange', {
      configurationStatus: _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].configurationStatus
    });
  }
  async waitUntilConfigured() {
    return new Promise(resolve => {
      if (this.getIsConfigurationStatus(AdapterConfigurationStatus.Configured)) resolve();else _classPrivateFieldLooseBase(this, _adapterState)[_adapterState].emitter.on(_classPrivateFieldLooseBase(this, _internalConfiguredStatusChange__)[_internalConfiguredStatusChange__], resolve);
    });
  }
  getFlag(flagName) {
    var _classPrivateFieldLoo;
    return (_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _adapterState)[_adapterState]) === null || _classPrivateFieldLoo === void 0 ? void 0 : _classPrivateFieldLoo.flags[flagName];
  }
}
const adapter = new MemoryAdapter();
exposeGlobally(adapter);

const version = "13.2.1";

export { adapter as default, version };
