import _Object$keys from '@babel/runtime-corejs3/core-js-stable/object/keys';
import _Object$getOwnPropertySymbols from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols';
import _filterInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/filter';
import _Object$getOwnPropertyDescriptor from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor';
import _forEachInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/for-each';
import _Object$getOwnPropertyDescriptors from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors';
import _Object$defineProperties from '@babel/runtime-corejs3/core-js-stable/object/define-properties';
import _Object$defineProperty from '@babel/runtime-corejs3/core-js-stable/object/define-property';
import _defineProperty from '@babel/runtime-corejs3/helpers/esm/defineProperty';
import _includesInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/includes';
import _Symbol$toPrimitive from '@babel/runtime-corejs3/core-js-stable/symbol/to-primitive';
import _objectWithoutProperties from '@babel/runtime-corejs3/helpers/esm/objectWithoutProperties';
import '@babel/runtime-corejs3/core-js-stable/instance/slice';
import _mapInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/map';
import _Object$fromEntries from '@babel/runtime-corejs3/core-js-stable/object/from-entries';
import _concatInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/concat';
import _Array$isArray from '@babel/runtime-corejs3/core-js-stable/array/is-array';
import _reduceInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/reduce';
import { faker } from '@faker-js/faker';
import mapValues from 'lodash/mapValues';
import _slicedToArray from '@babel/runtime-corejs3/helpers/esm/slicedToArray';
import _Object$entries from '@babel/runtime-corejs3/core-js-stable/object/entries';

const _excluded = ["name", "__typename"];
function ownKeys$3(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = _filterInstanceProperty(o).call(o, function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var _context4, _context5; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _forEachInstanceProperty(_context4 = ownKeys$3(Object(t), !0)).call(_context4, function (r) { _defineProperty(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context5 = ownKeys$3(Object(t))).call(_context5, function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[_Symbol$toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const isFunction = value => typeof value === 'function';
const isString = value => typeof value === 'string';
const isBuilderFunction = value => {
  var _context;
  return _includesInstanceProperty(_context = ['build', 'buildGraphql', 'buildRest']).call(_context, value);
};
const omitOne = (entity, prop) => {
  var _context2;
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  entity[prop];
    const newState = _objectWithoutProperties(entity, _mapInstanceProperty(_context2 = [prop]).call(_context2, _toPropertyKey));
  return newState;
};
const omitMany = function (entity) {
  let result = entity;
  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    props[_key - 1] = arguments[_key];
  }
  _forEachInstanceProperty(props).call(props, prop => {
    result = omitOne(result, prop);
  });
  return result;
};
const pickMany = function (entity) {
  for (var _len2 = arguments.length, props = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    props[_key2 - 1] = arguments[_key2];
  }
  const entries = _mapInstanceProperty(props).call(props, prop => [prop, entity[prop]]);
  return _Object$fromEntries(entries);
};
const convertTransformNameToBuildName = transformName => {
  switch (transformName) {
    case 'default':
      return 'build';
    case 'graphql':
      return 'buildGraphql';
    case 'rest':
      return 'buildRest';
    default:
      throw new Error("Unknown property build name ".concat(transformName));
  }
};
const toExpandedReference = typeId => data => typeId && data !== null && data !== void 0 && data.id ? {
  typeId,
  id: data.id,
  obj: data
} : null;
const toRestPaginatedQueryResult = function (list) {
  let _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref$total = _ref.total,
    total = _ref$total === void 0 ? 100 : _ref$total,
    _ref$offset = _ref.offset,
    offset = _ref$offset === void 0 ? 0 : _ref$offset;
  return {
    count: list.length || 0,
    total,
    offset,
    results: list
  };
};
const toGraphqlPaginatedQueryResult = (list, _ref2) => {
  let name = _ref2.name,
    __typename = _ref2.__typename,
    remainingOptions = _objectWithoutProperties(_ref2, _excluded);
  return _objectSpread$3({
    __typename: __typename !== null && __typename !== void 0 ? __typename : "".concat(name, "QueryResult")
  }, toRestPaginatedQueryResult(list, remainingOptions));
};
const buildField = function (builder) {
  let transformName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
  let meta = arguments.length > 2 ? arguments[2] : undefined;
  const buildName = convertTransformNameToBuildName(transformName);
  // @ts-ignore: TS does not know about the `Model` being an object.
  const builderField = builder === null || builder === void 0 ? void 0 : builder[buildName];
  // We need to cast this to `() => Model` as otherwise the value is unknown.
  // We know it's a function because of the proxy builder.
  const builderFn = builderField;
  if (!builderFn) {
    var _context3;
    throw new Error(_concatInstanceProperty(_context3 = "Builder with name '".concat(buildName, "' does not exist on field '")).call(_context3, String(meta === null || meta === void 0 ? void 0 : meta.fieldToBuild), "'."));
  }
  return builderFn();
};
const buildFields = function (builders) {
  let transformName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
  let meta = arguments.length > 2 ? arguments[2] : undefined;
  return _mapInstanceProperty(builders).call(builders, builder => buildField(builder, transformName, meta));
};
const buildGraphqlList = (builders, _ref3) => {
  let name = _ref3.name,
    total = _ref3.total,
    offset = _ref3.offset,
    __typename = _ref3.__typename;
  return toGraphqlPaginatedQueryResult(buildFields(builders, 'graphql'), {
    name,
    __typename,
    total,
    offset
  });
};
const buildRestList = (builders, _ref4) => {
  let total = _ref4.total,
    offset = _ref4.offset;
  return toRestPaginatedQueryResult(buildFields(builders, 'rest'), {
    total,
    offset
  });
};

function ownKeys$2(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = _filterInstanceProperty(o).call(o, function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var _context2, _context3; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _forEachInstanceProperty(_context2 = ownKeys$2(Object(t), !0)).call(_context2, function (r) { _defineProperty(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context3 = ownKeys$2(Object(t))).call(_context3, function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; }

// The Proxy constructor type does not differentiate between the target and the return type.
// Therefore, we define a custom constructor that requires a different return type.
const CustomProxy = Proxy;

// Internal state object to build up the final model.
const createState = function () {
  let _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    initial = _ref.initial;
  let state = initial ? _objectSpread$2({}, initial) : {};
  return {
    get: () => state,
    merge: update => {
      state = _objectSpread$2(_objectSpread$2({}, state), update);
    },
    set: (prop, value) => {
      state = _objectSpread$2(_objectSpread$2({}, state), {}, {
        [prop]: value
      });
    }
  };
};
function PropertyBuilder(initialProps) {
  const state = createState({
    initial: initialProps
  });
  const builder = new CustomProxy({}, {
    get(_target, prop) {
      switch (prop) {
        case 'get':
          {
            return () => state.get();
          }
        default:
          {
            return fnOrValue => {
              if (isFunction(fnOrValue)) {
                state.merge(fnOrValue(state.get()));
              } else if (isString(prop)) {
                state.set(prop, fnOrValue);
              }
              return builder;
            };
          }
      }
    }
  });
  return builder;
}
function Builder() {
  let _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    generator = _ref2.generator,
    transformers = _ref2.transformers;
  const applyGeneratorIfExists = () => {
    if (!generator) return {};
    return generator.generate();
  };
  const propertyBuilder = PropertyBuilder(applyGeneratorIfExists());
  const builder = {
    proxy: new CustomProxy({}, {
      get(_target, propToSet) {
        var _context;
        // Cypress specs and files that they import are now bundled with
        // webpack starting from Cypress 5 (webpack is now the default preprocessor).
        // This result in non-null check of
        // properties like `__esModule` and `default` to decide what has to be
        // provided as a module export. This means that e.g
        // `empty` in `LocalizedString.presets.empty.en` will be evaluated
        // to the returned function below this check, instead of `Proxy`. To avoid this
        // we need to check against these special properties.
        if (isString(propToSet) && _includesInstanceProperty(_context = ['__esModule', 'default']).call(_context, propToSet)) {
          return builder.proxy;
        }
        if (isBuilderFunction(propToSet)) {
          return function () {
            let _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              _ref3$omitFields = _ref3.omitFields,
              omitFields = _ref3$omitFields === void 0 ? [] : _ref3$omitFields,
              _ref3$keepFields = _ref3.keepFields,
              keepFields = _ref3$keepFields === void 0 ? [] : _ref3$keepFields;
            const built = propertyBuilder.get();
            let transformed = built;
            switch (propToSet) {
              case 'build':
                {
                  var _transformers$default, _transformers$default2;
                  transformed = (_transformers$default = transformers === null || transformers === void 0 || (_transformers$default2 = transformers.default) === null || _transformers$default2 === void 0 ? void 0 : _transformers$default2.transform(built)) !== null && _transformers$default !== void 0 ? _transformers$default : built;
                  break;
                }
              case 'buildGraphql':
                {
                  var _transformers$graphql, _transformers$graphql2;
                  transformed = (_transformers$graphql = transformers === null || transformers === void 0 || (_transformers$graphql2 = transformers.graphql) === null || _transformers$graphql2 === void 0 ? void 0 : _transformers$graphql2.transform(built)) !== null && _transformers$graphql !== void 0 ? _transformers$graphql : built;
                  break;
                }
              case 'buildRest':
                {
                  var _transformers$rest$tr, _transformers$rest;
                  transformed = (_transformers$rest$tr = transformers === null || transformers === void 0 || (_transformers$rest = transformers.rest) === null || _transformers$rest === void 0 ? void 0 : _transformers$rest.transform(built)) !== null && _transformers$rest$tr !== void 0 ? _transformers$rest$tr : built;
                  break;
                }
            }
            if (keepFields.length > 0) {
              return pickMany(transformed, ...keepFields);
            }
            if (omitFields.length > 0) {
              return omitMany(transformed, ...omitFields);
            }
            return transformed;
          };
        }
        return fnOrValue => {
          if (isString(propToSet)) {
            // @ts-ignore: TS does not know about the `Model` being an object.
            const propertyField = propertyBuilder[propToSet];
            const propertyFieldUpdater = propertyField;
            propertyFieldUpdater === null || propertyFieldUpdater === void 0 || propertyFieldUpdater(fnOrValue);
          }
          return builder.proxy;
        };
      }
    })
  };
  return builder.proxy;
}

function ownKeys$1(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = _filterInstanceProperty(o).call(o, function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var _context, _context2; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _forEachInstanceProperty(_context = ownKeys$1(Object(t), !0)).call(_context, function (r) { _defineProperty(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context2 = ownKeys$1(Object(t))).call(_context2, function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; }
const isGenerator = field => {
  if (!field) return false;
  return field.generatorType !== undefined;
};
const identity = x => x;
const buildTimeTraitsArray = buildTimeConfig => {
  const _buildTimeConfig$trai = buildTimeConfig.traits,
    traits = _buildTimeConfig$trai === void 0 ? [] : _buildTimeConfig$trai;
  return _Array$isArray(traits) ? traits : [traits];
};
const build = (factoryNameOrConfig, configObject) => {
  const config = typeof factoryNameOrConfig === 'string' ? configObject : factoryNameOrConfig;
  let sequenceCounter = 0;
  const expandConfigFields = function (fields) {
    let buildTimeConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const finalBuiltThing = mapValues(fields, (fieldValue, fieldKey) => {
      const overrides = buildTimeConfig.overrides || {};
      const traitsArray = buildTimeTraitsArray(buildTimeConfig);
      const traitOverrides = _reduceInstanceProperty(traitsArray).call(traitsArray, (overrides, currentTraitKey) => {
        const hasTrait = config.traits && config.traits[currentTraitKey];
        if (!hasTrait) {
          console.warn("Warning: trait '".concat(currentTraitKey, "' not found."));
        }
        const traitsConfig = config.traits ? config.traits[currentTraitKey] : {};
        return _objectSpread$1(_objectSpread$1({}, overrides), traitsConfig.overrides || {});
      }, {});
      const valueOrOverride = overrides[fieldKey] || traitOverrides[fieldKey] || fieldValue;

      /* eslint-disable-next-line @typescript-eslint/no-use-before-define */
      return expandConfigField(valueOrOverride);
    });
    return finalBuiltThing;
  };
  const expandConfigField = fieldValue => {
    let calculatedValue;
    if (isGenerator(fieldValue)) {
      switch (fieldValue.generatorType) {
        case 'sequence':
          {
            ++sequenceCounter;
            calculatedValue = fieldValue.call(fieldValue.userProvidedFunction, sequenceCounter);
            break;
          }
        case 'faker':
          {
            calculatedValue = fieldValue.call(faker);
            break;
          }
        case 'oneOf':
          {
            calculatedValue = fieldValue.call(fieldValue.options);
            break;
          }
        case 'perBuild':
          {
            calculatedValue = fieldValue.call(fieldValue.func);
            break;
          }
      }
    } else if (_Array$isArray(fieldValue)) {
      calculatedValue = _mapInstanceProperty(fieldValue).call(fieldValue, v => expandConfigField(v));
      return calculatedValue;
    } else if (fieldValue === null || fieldValue === undefined) {
      // has to be before typeof fieldValue === 'object'
      // as typeof null === 'object'
      calculatedValue = fieldValue;
    } else if (typeof fieldValue === 'object') {
      const nestedFieldsObject = fieldValue;
      calculatedValue = expandConfigFields(nestedFieldsObject);
    } else {
      calculatedValue = fieldValue;
    }
    return calculatedValue;
  };
  return function () {
    let buildTimeConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const fieldsToReturn = expandConfigFields(config.fields, buildTimeConfig);
    const traitsArray = buildTimeTraitsArray(buildTimeConfig);
    const traitPostBuilds = _mapInstanceProperty(traitsArray).call(traitsArray, traitName => {
      const traitConfig = config.traits && config.traits[traitName] || {};
      const postBuild = traitConfig.postBuild || identity;
      return postBuild;
    });
    const afterTraitPostBuildFields = _reduceInstanceProperty(traitPostBuilds).call(traitPostBuilds, (fields, traitPostBuild) => {
      return traitPostBuild(fields);
    }, fieldsToReturn);
    const postBuild = config.postBuild || identity;
    const buildTimeMapFunc = _mapInstanceProperty(buildTimeConfig) || identity;
    return buildTimeMapFunc(postBuild(afterTraitPostBuildFields));
  };
};
const oneOf = function () {
  for (var _len = arguments.length, options = new Array(_len), _key = 0; _key < _len; _key++) {
    options[_key] = arguments[_key];
  }
  return {
    generatorType: 'oneOf',
    options,
    call: options => {
      const randomIndex = Math.floor(Math.random() * options.length);
      return options[randomIndex];
    }
  };
};
const bool = () => oneOf(true, false);
const sequence = function () {
  let userProvidedFunction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : x => x;
  return {
    generatorType: 'sequence',
    userProvidedFunction,
    call: (userProvidedFunction, counter) => {
      return userProvidedFunction(counter);
    }
  };
};
const fake = userDefinedUsage => {
  return {
    generatorType: 'faker',
    call: faker => {
      return userDefinedUsage(faker);
    }
  };
};

function Generator(_ref) {
  let fields = _ref.fields,
    postBuild = _ref.postBuild;
  const originalGenerate = build({
    fields,
    postBuild
  });
  return {
    generate() {
      return originalGenerate();
    }
  };
}

function ownKeys(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = _filterInstanceProperty(o).call(o, function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var _context2, _context3; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _forEachInstanceProperty(_context2 = ownKeys(Object(t), !0)).call(_context2, function (r) { _defineProperty(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context3 = ownKeys(Object(t))).call(_context3, function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; }
function Transformer(transformType, transformOptions) {
  function transform(fields) {
    let transformedFields = _objectSpread({}, fields);
    const fieldsReplacer = transformOptions === null || transformOptions === void 0 ? void 0 : transformOptions.replaceFields;
    const fieldsAdder = transformOptions === null || transformOptions === void 0 ? void 0 : transformOptions.addFields;
    const fieldsToRemove = transformOptions === null || transformOptions === void 0 ? void 0 : transformOptions.removeFields;
    const fieldsToBuild = transformOptions === null || transformOptions === void 0 ? void 0 : transformOptions.buildFields;
    if (fieldsToBuild) {
      _forEachInstanceProperty(fieldsToBuild).call(fieldsToBuild, fieldToBuild => {
        const field = transformedFields[fieldToBuild];
        // Build only fields that are not null or undefined
        if (field) {
          transformedFields = _objectSpread(_objectSpread({}, transformedFields), {}, {
            [fieldToBuild]: _Array$isArray(field) ? buildFields(field, transformType, {
              fieldToBuild
            }) : buildField(field, transformType, {
              fieldToBuild
            })
          });
        }
      });
    }

    // The default transformer only allows building nested fields to not
    // allow re-transforming model shape
    if (transformType === 'default') {
      return transformedFields;
    }

    // If this is defined, all other options are ignored, as the transformed value
    // can be anything (object, array, scalar, etc.).
    if (fieldsReplacer) {
      if (fieldsAdder) {
        console.warn("The \"replaceFields\" option takes precedence over the \"addFields\" option, making it unused.");
      }
      if (fieldsToRemove) {
        console.warn("The \"replaceFields\" option takes precedence over the \"removeFields\" option, making it unused.");
      }
      return fieldsReplacer({
        fields: transformedFields
      });
    }
    if (fieldsAdder) {
      var _context;
      const fieldsToAdd = fieldsAdder({
        fields
      });
      _forEachInstanceProperty(_context = _Object$entries(fieldsToAdd)).call(_context, _ref => {
        let _ref2 = _slicedToArray(_ref, 2),
          fieldName = _ref2[0],
          fieldValue = _ref2[1];
        // @ts-ignore: TS does not know about the `Model` being an object.
        if (transformedFields[fieldName]) return;
        transformedFields = _objectSpread(_objectSpread({}, transformedFields), {}, {
          [fieldName]: fieldValue
        });
      });
    }
    if (fieldsToRemove) {
      _forEachInstanceProperty(fieldsToRemove).call(fieldsToRemove, fieldToRemove => {
        delete transformedFields[fieldToRemove];
      });
    }
    return transformedFields;
  }
  return {
    type: transformType,
    transform
  };
}

export { Builder, Generator, Transformer, bool, buildField, buildFields, buildGraphqlList, buildRestList, fake, oneOf, sequence, toExpandedReference, toGraphqlPaginatedQueryResult, toRestPaginatedQueryResult };
